///
/// JHybridOkhiNitroSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#include "JHybridOkhiNitroSpec.hpp"

// Forward declaration of `OkHiLogin` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct OkHiLogin; }
// Forward declaration of `OkHiAuth` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct OkHiAuth; }
// Forward declaration of `OkHiUser` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct OkHiUser; }
// Forward declaration of `OkHiLoginConfiguration` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct OkHiLoginConfiguration; }
// Forward declaration of `OkHiAppContext` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct OkHiAppContext; }
// Forward declaration of `OkHiVerificationType` to properly resolve imports.
namespace margelo::nitro::okhinitro { enum class OkHiVerificationType; }
// Forward declaration of `NitroOkCollect` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct NitroOkCollect; }
// Forward declaration of `NitroOkCollectStyle` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct NitroOkCollectStyle; }
// Forward declaration of `NitroOkCollectConfig` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct NitroOkCollectConfig; }
// Forward declaration of `NitroOkHiSuccessResponse` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct NitroOkHiSuccessResponse; }
// Forward declaration of `OkHiException` to properly resolve imports.
namespace margelo::nitro::okhinitro { struct OkHiException; }

#include "OkHiLogin.hpp"
#include "JOkHiLogin.hpp"
#include "OkHiAuth.hpp"
#include "JOkHiAuth.hpp"
#include <string>
#include <optional>
#include "OkHiUser.hpp"
#include "JOkHiUser.hpp"
#include "OkHiLoginConfiguration.hpp"
#include "JOkHiLoginConfiguration.hpp"
#include "OkHiAppContext.hpp"
#include "JOkHiAppContext.hpp"
#include <vector>
#include <functional>
#include "JFunc_void_std__optional_std__vector_std__string__.hpp"
#include <NitroModules/JNICallable.hpp>
#include "OkHiVerificationType.hpp"
#include "JOkHiVerificationType.hpp"
#include "NitroOkCollect.hpp"
#include "JNitroOkCollect.hpp"
#include "NitroOkCollectStyle.hpp"
#include "JNitroOkCollectStyle.hpp"
#include "NitroOkCollectConfig.hpp"
#include "JNitroOkCollectConfig.hpp"
#include "NitroOkHiSuccessResponse.hpp"
#include "OkHiException.hpp"
#include "JFunc_void_std__optional_NitroOkHiSuccessResponse__std__optional_OkHiException_.hpp"
#include "JNitroOkHiSuccessResponse.hpp"
#include "JOkHiException.hpp"

namespace margelo::nitro::okhinitro {

  jni::local_ref<JHybridOkhiNitroSpec::jhybriddata> JHybridOkhiNitroSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridOkhiNitroSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridOkhiNitroSpec::initHybrid),
    });
  }

  size_t JHybridOkhiNitroSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridOkhiNitroSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridOkhiNitroSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return javaString->toStdString();
  }

  // Properties
  

  // Methods
  void JHybridOkhiNitroSpec::login(const OkHiLogin& credentials, const std::function<void(const std::optional<std::vector<std::string>>& /* results */)>& callback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JOkHiLogin> /* credentials */, jni::alias_ref<JFunc_void_std__optional_std__vector_std__string__::javaobject> /* callback */)>("login_cxx");
    method(_javaPart, JOkHiLogin::fromCpp(credentials), JFunc_void_std__optional_std__vector_std__string___cxx::fromCpp(callback));
  }
  void JHybridOkhiNitroSpec::startAddressVerification(OkHiVerificationType type, const NitroOkCollect& okcollect, const std::function<void(const std::optional<NitroOkHiSuccessResponse>& /* response */, const std::optional<OkHiException>& /* error */)>& callback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JOkHiVerificationType> /* type */, jni::alias_ref<JNitroOkCollect> /* okcollect */, jni::alias_ref<JFunc_void_std__optional_NitroOkHiSuccessResponse__std__optional_OkHiException_::javaobject> /* callback */)>("startAddressVerification_cxx");
    method(_javaPart, JOkHiVerificationType::fromCpp(type), JNitroOkCollect::fromCpp(okcollect), JFunc_void_std__optional_NitroOkHiSuccessResponse__std__optional_OkHiException__cxx::fromCpp(callback));
  }

} // namespace margelo::nitro::okhinitro
